/*
 * Copyright 2004 OTP Systems Oy. All rights reserved.
 */

#include "JTuxInterop.h" /* Generated by javah at build time */

#include "java_nio_Buffer.h"
#include "jtux_holders_IntHolder.h"
#include "jtux_holders_StringHolder.h"
#include "jtux_holders_ByteBufferHolder.h"
#include "jtux_atmi_ATMI.h"
#include "jtux_atmi_TPINIT.h"
#include "jtux_atmi_CLIENTID.h"
#include "jtux_atmi_TPQCTL.h"
#include "jtux_atmi_TPEVCTL.h"
#include "jtux_atmi_TPTRANID.h"

#ifndef WSCLIENT
#include "JTuxJTA.h"
#include <tpadm.h>
#endif

#include "JTuxJNU.h"
#include "JTux.h"

#include "OTPJavaVM.h"
#include "OTPUserlog.h"

#include <fml32.h>
#include <atmi.h>

#include <jni.h>

#include <stdio.h>
#include <stdlib.h>

static JavaVM *theJvm = NULL;

#ifdef WSCLIENT
static char *product = "JTuxWS-" XSTR(JTUX_RELEASE);
#else
static char *product = "JTux-" XSTR(JTUX_RELEASE);
#endif

JNIEXPORT jint JNICALL
JNI_OnLoad(JavaVM *jvm, void *reserved)
{
    char *err = NULL;

#ifndef WSCLIENT
    if (JTuxJTAInitialize(jvm, 1, &err) == -1) {
	OTPUserlog("ERROR: Error initializing JTA module: %s", err);
	free(err);
	return JNI_ERR;
    }
#endif

    theJvm = jvm;

    return JNI_VERSION_1_4;
}

#define GET_NON_NULL_STRING_UTF_CHARS(VAR, EXCEPTION_LABEL) \
    if (VAR == NULL) { \
        JTuxThrowIllegalArgumentException(env, "null " #VAR); \
        goto EXCEPTION_LABEL; \
    } \
    c_##VAR = (char *) (*env)->GetStringUTFChars(env, VAR, NULL); \
    if (c_##VAR == NULL) { \
        goto EXCEPTION_LABEL; \
    }

#define RELEASE_NON_NULL_STRING_UTF_CHARS(VAR) \
    (*env)->ReleaseStringUTFChars(env, VAR, c_##VAR);

JNIEXPORT jstring JNICALL
Java_jtux_JTuxInterop_tuxgetenv(JNIEnv *env, jclass cls, jstring name)
{
    jstring result = NULL;

    char *c_name;
    char *value;

    GET_NON_NULL_STRING_UTF_CHARS(name, done);

    value = tuxgetenv(c_name);

    if (value != NULL) {
        result = (*env)->NewStringUTF(env, value);
    }

    RELEASE_NON_NULL_STRING_UTF_CHARS(name);

done:
    return result;
}

JNIEXPORT jint JNICALL
Java_jtux_JTuxInterop_tuxputenv(JNIEnv *env, jclass cls, jstring setting)
{
    jint result = 0;

    char *c_setting;

    GET_NON_NULL_STRING_UTF_CHARS(setting, done);

    result = tuxputenv(c_setting);

    RELEASE_NON_NULL_STRING_UTF_CHARS(setting);

done:
    return result;
}

#define GET_STRING_UTF_CHARS(VAR, EXCEPTION_LABEL) \
    if (VAR == NULL) { \
        c_##VAR = NULL; \
    } else { \
        c_##VAR = (char *) (*env)->GetStringUTFChars(env, VAR, NULL); \
        if (c_##VAR == NULL) { \
            goto EXCEPTION_LABEL; \
        } \
    }

#define RELEASE_STRING_UTF_CHARS(VAR) \
    if (c_##VAR != NULL) { \
        (*env)->ReleaseStringUTFChars(env, VAR, c_##VAR); \
    }

JNIEXPORT jint JNICALL
Java_jtux_JTuxInterop_tuxreadenv(JNIEnv *env, jclass cls, jstring file, 
    jstring label)
{
    jint result = 0;

    char *c_file;
    char *c_label;

    GET_STRING_UTF_CHARS(file, done);
    GET_STRING_UTF_CHARS(label, done_after_file);

    result = tuxreadenv(c_file, c_label);

    RELEASE_STRING_UTF_CHARS(label);

done_after_file:
    RELEASE_STRING_UTF_CHARS(file);

done:
    return result;
}

JNIEXPORT void JNICALL
Java_jtux_JTuxInterop_userlog(JNIEnv *env, jclass cls, jbyteArray bytes)
{
    if (bytes == NULL) {
        JTuxThrowIllegalArgumentException(env, "null message");
    } else {
        jint bytesLen = (*env)->GetArrayLength(env, bytes); 
        char *bytesPtr = (char *) (*env)->GetPrimitiveArrayCritical(env,
            bytes, NULL);
        if (bytesPtr != NULL) {
	    OTPUserlog("%.*s", bytesLen, bytesPtr);
            (*env)->ReleasePrimitiveArrayCritical(env, bytes, bytesPtr,
                JNI_ABORT);
        }
    }
}

#define GET_INPUT_BUFFER(DATA, EXCEPTION_LABEL) \
    if (DATA == NULL) { \
        c_##DATA = NULL; \
    } else { \
        c_##DATA = (char *) (*env)->GetDirectBufferAddress(env, DATA); \
        if (c_##DATA == NULL) { \
            goto EXCEPTION_LABEL; \
        } \
    }

#define GET_OUTPUT_BUFFER(DATA, EXCEPTION_LABEL) \
    if (DATA == NULL) { \
        JTuxThrowIllegalArgumentException(env, "null output data buffer " \
            "holder"); \
        goto EXCEPTION_LABEL; \
    } else { \
        jobject buffer = jtux_holders_ByteBufferHolder_get_value(env, \
            DATA); \
        if (buffer == NULL) { \
            JTuxThrowIllegalArgumentException(env, "null output data " \
                "buffer"); \
            goto EXCEPTION_LABEL; \
        } \
        c_##DATA = (char *) (*env)->GetDirectBufferAddress(env, buffer); \
        if (c_##DATA == NULL) { \
            (*env)->DeleteLocalRef(env, buffer); \
            goto EXCEPTION_LABEL; \
        } \
        (*env)->DeleteLocalRef(env, buffer); \
    }

#define GET_OUTPUT_BUFFER_AND_LEN(DATA, LEN, EXCEPTION_LABEL) \
    GET_OUTPUT_BUFFER(DATA, EXCEPTION_LABEL) \
    \
    if (LEN == NULL) { \
        JTuxThrowIllegalArgumentException(env, "null output length " \
            "holder"); \
        goto EXCEPTION_LABEL; \
    }

#define SET_OUTPUT_DATA_AND_LEN(DATA, LEN, EXCEPTION_LABEL) \
    if (c_##DATA == NULL) { \
        jtux_holders_ByteBufferHolder_set_value(env, DATA, NULL); \
    } else { \
        jobject buffer = JTuxNewTypedBuffer(env, c_##DATA, 0, c_##LEN); \
        if (buffer == NULL) { \
            goto EXCEPTION_LABEL; \
        } \
        jtux_holders_ByteBufferHolder_set_value(env, DATA, buffer); \
        (*env)->DeleteLocalRef(env, buffer); \
    } \
    \
    jtux_holders_IntHolder_set_value(env, LEN, c_##LEN);

#define SET_STRING_HOLDER_VALUE(VAR, EXCEPTION_LABEL) \
    jstring VAR = (*env)->NewStringUTF(env, c_##VAR); \
    if (VAR == NULL) { \
        goto EXCEPTION_LABEL; \
    } \
    jtux_holders_StringHolder_set_value(env, VAR##Holder, VAR); \
    (*env)->DeleteLocalRef(env, VAR); 

#define GET_TPINIT_FIELD(FIELD, EXCEPTION_LABEL) \
    jstring FIELD = jtux_atmi_TPINIT_get_##FIELD(env, tpinfo); \
    if (FIELD == NULL) { \
        c_tpinfo->FIELD[0] = '\0'; \
    } else { \
        jint utfLen = (*env)->GetStringUTFLength(env, FIELD); \
        if (utfLen > MAXTIDENT) { \
            JTuxThrowIllegalArgumentException(env, "TPINIT." #FIELD \
                " too long"); \
            (*env)->DeleteLocalRef(env, FIELD); \
            goto EXCEPTION_LABEL; \
        } else { \
            jint len = (*env)->GetStringLength(env, FIELD); \
            (*env)->GetStringUTFRegion(env, FIELD, 0, len, c_tpinfo->FIELD); \
            c_tpinfo->FIELD[utfLen] = '\0'; \
            (*env)->DeleteLocalRef(env, FIELD); \
        } \
    }

static TPINIT *newTPINIT(JNIEnv *env, jobject tpinfo)
{
    jbyteArray data = jtux_atmi_TPINIT_get_data(env, tpinfo);

    jsize datalen = (data == NULL) ? 0 : (*env)->GetArrayLength(env, data);

    TPINIT *c_tpinfo = (TPINIT *) tpalloc("TPINIT", NULL, TPINITNEED(datalen));
    if (c_tpinfo == NULL) {
        JTuxThrowRuntimeException(env, "tpalloc() failed "
            "trying to allocate TPINIT buffer");
        goto exception;
    }

    { GET_TPINIT_FIELD(usrname, exception_after_c_tpinfo); }

    { GET_TPINIT_FIELD(cltname, exception_after_c_tpinfo); }

    { GET_TPINIT_FIELD(passwd, exception_after_c_tpinfo); }

    { GET_TPINIT_FIELD(grpname, exception_after_c_tpinfo); }

    c_tpinfo->flags = jtux_atmi_TPINIT_get_flags(env, tpinfo);

    c_tpinfo->datalen = (long) datalen;

    if (data != NULL) {
        (*env)->GetByteArrayRegion(env, data, 0, datalen,
            (jbyte *) &c_tpinfo->data);
        (*env)->DeleteLocalRef(env, data);
    }

    return c_tpinfo;

exception_after_c_tpinfo:

    tpfree((char *) c_tpinfo);

exception:

    return NULL;
}

static jobject newCLIENTID(JNIEnv *env, CLIENTID *c_cltid)
{
    jobject obj = jtux_atmi_CLIENTID_new(env);
    if (obj != NULL) {
        jtux_atmi_CLIENTID_set_clientdata0(env, obj, c_cltid->clientdata[0]);
        jtux_atmi_CLIENTID_set_clientdata1(env, obj, c_cltid->clientdata[1]);
        jtux_atmi_CLIENTID_set_clientdata2(env, obj, c_cltid->clientdata[2]);
        jtux_atmi_CLIENTID_set_clientdata3(env, obj, c_cltid->clientdata[3]);
    }
    return obj;
}

static void read_CLIENTID(JNIEnv *env, jobject cltid, CLIENTID *c_cltid)
{
    c_cltid->clientdata[0] = jtux_atmi_CLIENTID_get_clientdata0(env, cltid);
    c_cltid->clientdata[1] = jtux_atmi_CLIENTID_get_clientdata1(env, cltid);
    c_cltid->clientdata[2] = jtux_atmi_CLIENTID_get_clientdata2(env, cltid);
    c_cltid->clientdata[3] = jtux_atmi_CLIENTID_get_clientdata3(env, cltid);
}

#define GET_TPQCTL_MSGID(MSGID) \
    jbyteArray MSGID = jtux_atmi_TPQCTL_get_##MSGID(env, ctl); \
    if (MSGID == NULL) { \
        JTuxThrowIllegalArgumentException(env, "TPQCTL." #MSGID " not set"); \
        return -1; \
    } \
    if ((*env)->GetArrayLength(env, MSGID) != 32) { \
        JTuxThrowIllegalArgumentException(env, "TPQCTL." #MSGID " length " \
            "invalid"); \
        (*env)->DeleteLocalRef(env, MSGID); \
        return -1; \
    } \
    (*env)->GetByteArrayRegion(env, MSGID, 0, 32, (jbyte *) c_ctl->MSGID); \
    (*env)->DeleteLocalRef(env, MSGID);

#define SET_TPQCTL_MSGID(MSGID) \
    jbyteArray MSGID = (*env)->NewByteArray(env, 32); \
    if (MSGID == NULL) { \
        return -1; \
    } \
    (*env)->SetByteArrayRegion(env, MSGID, 0, 32, (jbyte *) c_ctl->MSGID); \
    jtux_atmi_TPQCTL_set_##MSGID(env, ctl, MSGID); \
    (*env)->DeleteLocalRef(env, MSGID);

#define GET_TPQCTL_QNAME(QNAME) \
    jstring QNAME = jtux_atmi_TPQCTL_get_##QNAME(env, ctl); \
    if (QNAME == NULL) { \
        JTuxThrowIllegalArgumentException(env, "TPQCTL." #QNAME " not set"); \
        return -1; \
    } else { \
        jint utfLen = (*env)->GetStringUTFLength(env, QNAME); \
        if (utfLen > 15) { \
            JTuxThrowIllegalArgumentException(env, "TPQCTL." #QNAME \
                " too long"); \
            (*env)->DeleteLocalRef(env, QNAME); \
            return -1; \
        } else { \
            jint len = (*env)->GetStringLength(env, QNAME); \
            (*env)->GetStringUTFRegion(env, QNAME, 0, len, c_ctl->QNAME); \
            c_ctl->QNAME[utfLen] = '\0'; \
            (*env)->DeleteLocalRef(env, QNAME); \
        } \
    }

#define SET_TPQCTL_QNAME(QNAME) \
    jstring QNAME = (*env)->NewStringUTF(env, c_ctl->QNAME); \
    if (QNAME == NULL) { \
        return -1; \
    } \
    jtux_atmi_TPQCTL_set_##QNAME(env, ctl, QNAME); \
    (*env)->DeleteLocalRef(env, QNAME);

static int read_TPQCTL_before_enqueue(JNIEnv *env, jobject ctl, TPQCTL *c_ctl)
{
    c_ctl->flags = (long) jtux_atmi_TPQCTL_get_flags(env, ctl);

    if (c_ctl->flags & (TPQTIME_ABS | TPQTIME_REL)) {
        c_ctl->deq_time = jtux_atmi_TPQCTL_get_deq_time(env, ctl);
    }

    if (c_ctl->flags & TPQPRIORITY) {
        c_ctl->priority = jtux_atmi_TPQCTL_get_priority(env, ctl);
    }

    if (c_ctl->flags & (TPQEXPTIME_ABS | TPQEXPTIME_REL)) {
        c_ctl->exp_time = jtux_atmi_TPQCTL_get_exp_time(env, ctl);
    }

    if (c_ctl->flags & TPQDELIVERYQOS) {
        c_ctl->delivery_qos = jtux_atmi_TPQCTL_get_delivery_qos(env, ctl);
    }

    if (c_ctl->flags & TPQREPLYQOS) {
        c_ctl->reply_qos = jtux_atmi_TPQCTL_get_reply_qos(env, ctl);
    }

    c_ctl->urcode = (long) jtux_atmi_TPQCTL_get_urcode(env, ctl);

    if (c_ctl->flags & TPQBEFOREMSGID) {
        GET_TPQCTL_MSGID(msgid);
    }

    if (c_ctl->flags & TPQCORRID) {
        GET_TPQCTL_MSGID(corrid);
    }

    if (c_ctl->flags & TPQREPLYQ) {
        GET_TPQCTL_QNAME(replyqueue);
    }

    if (c_ctl->flags & TPQFAILUREQ) {
        GET_TPQCTL_QNAME(failurequeue);
    }

    return 0;
}

static int write_TPQCTL_after_enqueue(JNIEnv *env, jobject ctl, TPQCTL *c_ctl)
{
    jtux_atmi_TPQCTL_set_flags(env, ctl, c_ctl->flags);

    if (c_ctl->flags & TPQMSGID) {
        SET_TPQCTL_MSGID(msgid);
    }

    return 0;
}

static int read_TPQCTL_before_dequeue(JNIEnv *env, jobject ctl, TPQCTL *c_ctl)
{
    c_ctl->flags = (long) jtux_atmi_TPQCTL_get_flags(env, ctl); 

    if (c_ctl->flags & TPQGETBYMSGID) {
        GET_TPQCTL_MSGID(msgid);
    }

    if (c_ctl->flags & TPQGETBYCORRID) {
        GET_TPQCTL_MSGID(corrid);
    }

    return 0;
}

static int write_TPQCTL_after_dequeue(JNIEnv *env, jobject ctl, TPQCTL *c_ctl)
{
    jtux_atmi_TPQCTL_set_flags(env, ctl, c_ctl->flags);

    if (c_ctl->flags & TPQPRIORITY) {
        jtux_atmi_TPQCTL_set_priority(env, ctl, c_ctl->priority);
    }

    if (c_ctl->flags & TPQMSGID) {
        SET_TPQCTL_MSGID(msgid);
    }

    if (c_ctl->flags & TPQCORRID) {
        SET_TPQCTL_MSGID(corrid);
    }

    if (c_ctl->flags & TPQDELIVERYQOS) {
        jtux_atmi_TPQCTL_set_delivery_qos(env, ctl, c_ctl->delivery_qos);
    }

    if (c_ctl->flags & TPQREPLYQOS) {
        jtux_atmi_TPQCTL_set_reply_qos(env, ctl, c_ctl->reply_qos);
    }

    if (c_ctl->flags & TPQREPLYQ) {
        SET_TPQCTL_QNAME(replyqueue);
    }

    if (c_ctl->flags & TPQFAILUREQ) {
        SET_TPQCTL_QNAME(failurequeue);
    }

    jtux_atmi_TPQCTL_set_appkey(env, ctl, c_ctl->appkey);

    jtux_atmi_TPQCTL_set_urcode(env, ctl, c_ctl->urcode);

    {
        jobject cltid = newCLIENTID(env, &c_ctl->cltid);
        if (cltid == NULL) {
            return -1;
        }
        jtux_atmi_TPQCTL_set_cltid(env, ctl, cltid);
        (*env)->DeleteLocalRef(env, cltid);
    }

    return 0;
}

static void read_TPTRANID(JNIEnv *env, jobject tid, TPTRANID *c_tid)
{
    c_tid->info[0] = jtux_atmi_TPTRANID_get_info0(env, tid);
    c_tid->info[1] = jtux_atmi_TPTRANID_get_info1(env, tid);
    c_tid->info[2] = jtux_atmi_TPTRANID_get_info2(env, tid);
    c_tid->info[3] = jtux_atmi_TPTRANID_get_info3(env, tid);
    c_tid->info[4] = jtux_atmi_TPTRANID_get_info4(env, tid);
    c_tid->info[5] = jtux_atmi_TPTRANID_get_info5(env, tid);
}

static void write_TPTRANID(JNIEnv *env, jobject tid, TPTRANID *c_tid)
{
    jtux_atmi_TPTRANID_set_info0(env, tid, c_tid->info[0]);
    jtux_atmi_TPTRANID_set_info1(env, tid, c_tid->info[1]);
    jtux_atmi_TPTRANID_set_info2(env, tid, c_tid->info[2]);
    jtux_atmi_TPTRANID_set_info3(env, tid, c_tid->info[3]);
    jtux_atmi_TPTRANID_set_info4(env, tid, c_tid->info[4]);
    jtux_atmi_TPTRANID_set_info5(env, tid, c_tid->info[5]);
}

#define GET_TPEVCTL_NAME(NAME) \
    jstring NAME = jtux_atmi_TPEVCTL_get_##NAME(env, ctl); \
    if (NAME == NULL) { \
        JTuxThrowIllegalArgumentException(env, "TPEVCTL." #NAME \
            " not set"); \
        return -1; \
    } else { \
        jint utfLen = (*env)->GetStringUTFLength(env, NAME); \
        if (utfLen > 30) { \
            JTuxThrowIllegalArgumentException(env, "TPEVCTL." #NAME \
                " too long"); \
            (*env)->DeleteLocalRef(env, NAME); \
            return -1; \
        } else { \
            jint len = (*env)->GetStringLength(env, NAME); \
            (*env)->GetStringUTFRegion(env, NAME, 0, len, c_ctl->NAME); \
            c_ctl->NAME[utfLen] = '\0'; \
            (*env)->DeleteLocalRef(env, NAME); \
        } \
    }

static int read_TPEVCTL(JNIEnv *env, jobject ctl, TPEVCTL *c_ctl)
{
    c_ctl->flags = (long) jtux_atmi_TPEVCTL_get_flags(env, ctl);

    if (c_ctl->flags & (TPEVSERVICE | TPEVQUEUE)) {
        GET_TPEVCTL_NAME(name1);
    }

    if (c_ctl->flags & TPEVQUEUE) {
        GET_TPEVCTL_NAME(name2);
        {
            jobject qctl = jtux_atmi_TPEVCTL_get_qctl(env, ctl);
            if (qctl == NULL) {
                JTuxThrowIllegalArgumentException(env,
                    "TPEVCTL.qctl not set");
                return -1;
            }
            if (read_TPQCTL_before_enqueue(env, qctl, &c_ctl->qctl) == -1) {
                (*env)->DeleteLocalRef(env, qctl);
                return -1;
            }
            (*env)->DeleteLocalRef(env, qctl);
        }
    }

    return 0;
}

#ifdef _WIN32
#define UNSOL_FUNC __stdcall
#else
#define UNSOL_FUNC
#endif

static void UNSOL_FUNC tpunsol(char *data, long len, long flags)
{
    char *err = NULL;

    JNIEnv *env;

    jobject jdata;

    if (OTPJavaVMGetEnv(theJvm, JNI_VERSION_1_4, &env, &err) == -1) {

	/*
	 * This call fails if the unsolicited message is delivered in a
	 * non-JVM thread. This seems to happen in Workstation clients
	 * on HP-UX and perhaps Solaris as well, even if the delivery mode
	 * has been set to dipin. Unfortunately, there is not much we can
	 * do in this case. Temporarily attaching the thread to the JVM is
	 * too risky as the thread's stack may not be large enough, causing
	 * a JVM crash later on.
	 */

	OTPUserlog("ERROR: Error getting JNIEnv in tpunsol(): %s", err);
	free(err);
        return;
    }

    jdata = JTuxNewTypedBuffer(env, data, 0, len);
    if (jdata == NULL) {
        goto exception;
    }

    jtux_atmi_ATMI_call_tpunsol(env, jdata, len, flags);

    (*env)->DeleteLocalRef(env, jdata);

    if ((*env)->ExceptionCheck(env)) {
        goto exception;
    }

    return;

exception:

    OTPUserlog("ERROR: Exception in tpunsol()");
    JTuxLogAndClearException(env);
}

JNIEXPORT jint JNICALL
Java_jtux_JTuxInterop_tperrno(JNIEnv *env, jclass cls)
{
    return tperrno;
}

JNIEXPORT jstring JNICALL
Java_jtux_JTuxInterop_tpstrerror(JNIEnv *env, jclass cls, jint err)
{
    char *errMessage = tpstrerror(err);
    if (errMessage == NULL) {
        return NULL;
    }
    return (*env)->NewStringUTF(env, errMessage);
}

JNIEXPORT jint JNICALL
Java_jtux_JTuxInterop_tpurcode(JNIEnv *env, jclass cls)
{
    return tpurcode;
}

JNIEXPORT jobject JNICALL
Java_jtux_JTuxInterop_tpalloc(JNIEnv *env, jclass cls, jstring type, 
    jstring subtype, jint size)
{
    jobject result = NULL;

    char *c_type;
    char *c_subtype;
    char *c_result;

    GET_STRING_UTF_CHARS(type, done);
    GET_STRING_UTF_CHARS(subtype, done_after_type)

    c_result = tpalloc(c_type, c_subtype, size);

    if (c_result != NULL) {
        result = JTuxNewTypedBuffer(env, c_result, 0, size);
    }

    RELEASE_STRING_UTF_CHARS(subtype);

done_after_type:
    RELEASE_STRING_UTF_CHARS(type);

done:
    return result;
}

JNIEXPORT jint JNICALL
Java_jtux_JTuxInterop_tptypes(JNIEnv *env, jclass cls, jobject buffer, 
   jobject typeHolder, jobject subtypeHolder)
{
    jint result;

    char *c_buffer;
    char c_type[8 + 1];
    char c_subtype[16 + 1];

    GET_INPUT_BUFFER(buffer, done);

    result = tptypes(c_buffer, (typeHolder == NULL) ? NULL : c_type,
        (subtypeHolder == NULL) ? NULL : c_subtype);

    if (result != -1) {
        if (typeHolder != NULL) {
            c_type[8] = 0;
            { SET_STRING_HOLDER_VALUE(type, done); }
        }
        if (subtypeHolder != NULL) {
            c_subtype[16] = 0;
            { SET_STRING_HOLDER_VALUE(subtype, done); }
        }
    }

done:
    return result;
}

JNIEXPORT jobject JNICALL
Java_jtux_JTuxInterop_tprealloc(JNIEnv *env, jclass cls, jobject buffer, 
    jint size)
{
    jobject result = NULL;

    long position;

    char *c_buffer;
    char *c_result;

    if (buffer == NULL) {
        position = 0;
    } else {
        position = java_nio_Buffer_call_get_position(env, buffer);
        if ((*env)->ExceptionCheck(env)) {
            goto done;
        }
    }

    GET_INPUT_BUFFER(buffer, done);

    c_result = tprealloc(c_buffer, size);

    if (c_result != NULL) {
        if (position > size) {
            position = size;
        }
        result = JTuxNewTypedBuffer(env, c_result, position, size);
    }

done:
    return result;
}

JNIEXPORT void JNICALL
Java_jtux_JTuxInterop_tpfree(JNIEnv *env, jclass cls, jobject buffer)
{
    char *c_buffer;

    GET_INPUT_BUFFER(buffer, done);

    if (c_buffer != NULL) {
        tpfree(c_buffer);
    }

done:
    return;
}

JNIEXPORT jint JNICALL
Java_jtux_JTuxInterop_tpadmcall(JNIEnv *env, jclass cls, jobject idata, 
    jobject odata, jint flags)
{
#ifdef WSCLIENT
    JTuxThrowUnsupportedOperationException(env, "No tpadmcall() in /WS");
    return 0;
#else
    jint result = 0;

    char* c_idata;
    char* c_odata;

    GET_INPUT_BUFFER(idata, done);
    GET_OUTPUT_BUFFER(odata, done);

    result = tpadmcall((FBFR32 *) c_idata, (FBFR32 **) &c_odata, flags);

    if ((result != -1) || (tperrno == TPEMIB)) {
        if (c_odata == NULL) {
            jtux_holders_ByteBufferHolder_set_value(env, odata, NULL);
        } else {
            long size = Fsizeof32((FBFR32 *) c_odata);
            if (size == -1) {
                JTuxThrowRuntimeException(env, "Fsizeof32() failed "
                    "on FML32 buffer received from Tuxedo");
                goto done;
            } else {
                jobject buffer = JTuxNewTypedBuffer(env, c_odata, 0,
                    size);
                if (buffer == NULL) {
                    goto done;
                }
                jtux_holders_ByteBufferHolder_set_value(env, odata, buffer);
                (*env)->DeleteLocalRef(env, buffer);
            }
        }
    }

done:
    return result;
#endif
}

JNIEXPORT jint JNICALL
Java_jtux_JTuxInterop_tpgetctxt(JNIEnv *env, jclass cls, jobject ctxt, 
    jint flags)
{
    if (ctxt == NULL) {
        return tpgetctxt(NULL, flags);
    } else {
        TPCONTEXT_T c_ctxt;
        jint result = tpgetctxt(&c_ctxt, flags);
        if (result != -1) {
            jtux_holders_IntHolder_set_value(env, ctxt, (jint) c_ctxt);
        }
        return result;
    }
}

JNIEXPORT jint JNICALL
Java_jtux_JTuxInterop_tpsetctxt(JNIEnv *env, jclass cls, jint ctxt, 
    jint flags)
{
    return tpsetctxt((TPCONTEXT_T) ctxt, flags);
}

JNIEXPORT jint JNICALL
Java_jtux_JTuxInterop_tpchkauth(JNIEnv *env, jclass cls)
{
    return tpchkauth();
}

JNIEXPORT jint JNICALL
Java_jtux_JTuxInterop_tpinit(JNIEnv *env, jclass cls, jobject tpinfo)
{
    jint result = 0;

    TPINIT *c_tpinfo;

    if (tpinfo == NULL) {
        c_tpinfo = NULL;
    } else {
        c_tpinfo = newTPINIT(env, tpinfo);
        if (c_tpinfo == NULL) {
            goto done;
        }
    }

    result = tpinit(c_tpinfo);

    if ((result != -1) && (tpinfo != NULL)) {
        jtux_atmi_TPINIT_set_flags(env, tpinfo, c_tpinfo->flags);
        /* ! (see tpinit(3c)) */
    }

    if (c_tpinfo != NULL) {
        tpfree((char *) c_tpinfo);
    }

done:
    return result;
}

JNIEXPORT jint JNICALL
Java_jtux_JTuxInterop_tpterm(JNIEnv *env, jclass cls)
{
    return tpterm();
}

JNIEXPORT jint JNICALL
Java_jtux_JTuxInterop_tpacall(JNIEnv *env, jclass cls, jstring svc, 
    jobject data, jint len, jint flags)
{
    jint result = 0;

    char *c_svc;
    char *c_data;

    GET_STRING_UTF_CHARS(svc, done);
    GET_INPUT_BUFFER(data, done_after_svc);

    result = tpacall(c_svc, c_data, len, flags);

done_after_svc:
    RELEASE_STRING_UTF_CHARS(svc);

done:
    return result;
}

JNIEXPORT jint JNICALL
Java_jtux_JTuxInterop_tpgetrply(JNIEnv *env, jclass cls, jobject cd, 
    jobject data, jobject len, jint flags)
{
    jint result;

    int c_cd;
    char *c_data;
    long c_len;

    if (cd == NULL) {
        JTuxThrowIllegalArgumentException(env,
            "null call descriptor holder");
        goto done;
    }
    c_cd = jtux_holders_IntHolder_get_value(env, cd);

    GET_OUTPUT_BUFFER_AND_LEN(data, len, done);

    result = tpgetrply(&c_cd, &c_data, &c_len, flags);

    /* cd must always be updated */

    jtux_holders_IntHolder_set_value(env, cd, c_cd);

    if ((result != -1) || (tperrno == TPESVCFAIL)) {
        SET_OUTPUT_DATA_AND_LEN(data, len, done);
    }

done:
    return result;
}

JNIEXPORT jint JNICALL
Java_jtux_JTuxInterop_tpcancel(JNIEnv *env, jclass cls, jint cd)
{
    return tpcancel(cd);
}

JNIEXPORT jint JNICALL
Java_jtux_JTuxInterop_tpcall(JNIEnv *env, jclass cls, jstring svc, 
    jobject idata, jint ilen, jobject odata, jobject olen, jint flags)
{
    jint result = 0;

    char *c_svc;
    char *c_idata;
    char *c_odata;
    long c_olen;

    GET_STRING_UTF_CHARS(svc, done);
    GET_INPUT_BUFFER(idata, done_after_svc);
    GET_OUTPUT_BUFFER_AND_LEN(odata, olen, done_after_svc);

    result = tpcall(c_svc, c_idata, ilen, &c_odata, &c_olen, flags);

    if ((result != -1) || (tperrno == TPESVCFAIL)) {
        SET_OUTPUT_DATA_AND_LEN(odata, olen, done_after_svc);
    }

done_after_svc:
    RELEASE_STRING_UTF_CHARS(svc);

done:
    return result;
}

JNIEXPORT jint JNICALL
Java_jtux_JTuxInterop_tpconnect(JNIEnv *env, jclass cls, jstring svc, 
    jobject data, jint len, jint flags)
{
    jint result = 0;

    char *c_svc;
    char *c_data;

    GET_STRING_UTF_CHARS(svc, done);
    GET_INPUT_BUFFER(data, done_after_svc);

    result = tpconnect(c_svc, c_data, len, flags);

done_after_svc:
    RELEASE_STRING_UTF_CHARS(svc);

done:
    return result;
}

JNIEXPORT jint JNICALL
Java_jtux_JTuxInterop_tpsend(JNIEnv *env, jclass cls, jint cd, 
    jobject data, jint len, jint flags, jobject revent)
{
    jint result;

    char *c_data;
    long c_revent;

    GET_INPUT_BUFFER(data, done);

    if (revent == NULL) {
        JTuxThrowIllegalArgumentException(env, "null event holder");
        goto done;
    }

    result = tpsend(cd, c_data, len, flags, &c_revent);

    if ((result == -1) && (tperrno == TPEEVENT)) {
        jtux_holders_IntHolder_set_value(env, revent, c_revent);
    }

done:
    return result;
}

JNIEXPORT jint JNICALL
Java_jtux_JTuxInterop_tprecv(JNIEnv *env, jclass cls, jint cd, 
    jobject data, jobject len, jint flags, jobject revent)
{
    jint result;

    char *c_data;
    long c_len;
    long c_revent;

    GET_OUTPUT_BUFFER_AND_LEN(data, len, done);

    if (revent == NULL) {
        JTuxThrowIllegalArgumentException(env, "null event holder");
        goto done;
    }

    result = tprecv(cd, &c_data, &c_len, flags, &c_revent);

    if ((result != -1) || (tperrno == TPEEVENT)) {
        if ((result != -1) || (c_revent == TPEV_SENDONLY)
            || (c_revent == TPEV_SVCSUCC) || (c_revent == TPEV_SVCFAIL)) {
            SET_OUTPUT_DATA_AND_LEN(data, len, done);
        }
        if (result == -1) {
            jtux_holders_IntHolder_set_value(env, revent, c_revent);
        }
    }

done:
    return result;
}

JNIEXPORT jint JNICALL
Java_jtux_JTuxInterop_tpdiscon(JNIEnv *env, jclass cls, jint cd)
{
    return tpdiscon(cd);
}

JNIEXPORT jint JNICALL
Java_jtux_JTuxInterop_tpenqueue(JNIEnv *env, jclass cls, jstring qspace, 
    jstring qname, jobject ctl, jobject data, jint len, jint flags)
{
    jint result = 0;

    char *c_qspace;
    char *c_qname;
    TPQCTL c_ctl;
    char *c_data;

    GET_STRING_UTF_CHARS(qspace, done);
    GET_STRING_UTF_CHARS(qname, done_after_qspace);

    /*
    * tpenqueue(3c) says the following about the ctl parameter:
    *
    *     "If this parameter is NULL, the input flags are considered to
    *     be TPNOFLAGS and no output information is made available to the
    *     application program."
    *
    * On Windows, however, tpenqueue() crashes when ctl == NULL. Fortunately,
    * we never pass NULL to tpenqueue() ourselves because we always use a
    * TPQCTL for the diagnostic value. Better keep it that way.
    */

    if (ctl == NULL) {
        c_ctl.flags = TPNOFLAGS;
    } else {
        if (read_TPQCTL_before_enqueue(env, ctl, &c_ctl) == -1) {
            goto done_after_qname;
        }
    }

    GET_INPUT_BUFFER(data, done_after_qname);

    result = tpenqueue(c_qspace, c_qname, &c_ctl, c_data, len, flags);

    if (ctl != NULL) {
        if (result != -1) {
            if (write_TPQCTL_after_enqueue(env, ctl, &c_ctl) == -1) {
                goto done_after_qname;
            }
        } else if (tperrno == TPEDIAGNOSTIC) {
            jtux_atmi_TPQCTL_set_diagnostic(env, ctl, c_ctl.diagnostic);
        }
    }

done_after_qname:
    RELEASE_STRING_UTF_CHARS(qname);

done_after_qspace:
    RELEASE_STRING_UTF_CHARS(qspace);

done:
    return result;
}

JNIEXPORT jint JNICALL
Java_jtux_JTuxInterop_tpdequeue(JNIEnv *env, jclass cls, jstring qspace, 
    jstring qname, jobject ctl, jobject data, jobject len, jint flags)
{
    jint result = 0;

    char *c_qspace;
    char *c_qname;
    TPQCTL c_ctl;
    char *c_data;
    long c_len;

    GET_STRING_UTF_CHARS(qspace, done);
    GET_STRING_UTF_CHARS(qname, done_after_qspace);

    if (ctl == NULL) {
        c_ctl.flags = TPNOFLAGS;
    } else {
        if (read_TPQCTL_before_dequeue(env, ctl, &c_ctl) == -1) {
            goto done_after_qname;
        }
    }

    GET_OUTPUT_BUFFER_AND_LEN(data, len, done_after_qname);

    result = tpdequeue(c_qspace, c_qname, &c_ctl, &c_data, &c_len, flags);

    if (ctl != NULL) {
        if (result != -1) {
            if (write_TPQCTL_after_dequeue(env, ctl, &c_ctl) == -1) {
                goto done_after_qname;
            }
        } else if (tperrno == TPEDIAGNOSTIC) {
            jtux_atmi_TPQCTL_set_diagnostic(env, ctl, c_ctl.diagnostic);
        }
    }

    if (result != -1) {
        SET_OUTPUT_DATA_AND_LEN(data, len, done_after_qname);
    }

done_after_qname:
    RELEASE_STRING_UTF_CHARS(qname);

done_after_qspace:
    RELEASE_STRING_UTF_CHARS(qspace);

done:
    return result;
}

JNIEXPORT jint JNICALL
Java_jtux_JTuxInterop_tpbegin(JNIEnv *env, jclass cls, jint timeout, 
    jint flags)
{
    return tpbegin((unsigned long) timeout, flags);
}

JNIEXPORT jint JNICALL
Java_jtux_JTuxInterop_tpabort(JNIEnv *env, jclass cls, jint flags)
{
    return tpabort(flags);
}

JNIEXPORT jint JNICALL
Java_jtux_JTuxInterop_tpcommit(JNIEnv *env, jclass cls, jint flags)
{
    return tpcommit(flags);
}

JNIEXPORT jint JNICALL
Java_jtux_JTuxInterop_tpgetlev(JNIEnv *env, jclass cls)
{
    return tpgetlev();
}

JNIEXPORT jint JNICALL
Java_jtux_JTuxInterop_tpscmt(JNIEnv *env, jclass cls, jint flags)
{
    return tpscmt(flags);
}

JNIEXPORT jint JNICALL
Java_jtux_JTuxInterop_tpsuspend(JNIEnv *env, jclass cls, jobject tranid, 
    jint flags)
{
    if (tranid == NULL) {
        return tpsuspend(NULL, flags);
    } else {
        TPTRANID c_tranid;
        jint result = tpsuspend(&c_tranid, flags);
        if (result != -1) {
            write_TPTRANID(env, tranid, &c_tranid);
        }
        return result;
    }
}

JNIEXPORT jint JNICALL
Java_jtux_JTuxInterop_tpresume(JNIEnv *env, jclass cls, jobject tranid, 
    jint flags)
{
    if (tranid == NULL) {
        return tpresume(NULL, flags);
    } else {
        TPTRANID c_tranid;
        read_TPTRANID(env, tranid, &c_tranid);
        return tpresume(&c_tranid, flags);
    }
}

JNIEXPORT jint JNICALL
Java_jtux_JTuxInterop_tpopen(JNIEnv *env, jclass cls)
{
#ifdef WSCLIENT
    JTuxThrowUnsupportedOperationException(env, "No tpopen() in /WS");
    return 0;
#else
    return tpopen();
#endif
}

JNIEXPORT jint JNICALL
Java_jtux_JTuxInterop_tpclose(JNIEnv *env, jclass cls)
{
#ifdef WSCLIENT
    JTuxThrowUnsupportedOperationException(env, "No tpclose() in /WS");
    return 0;
#else
    return tpclose();
#endif
}

JNIEXPORT jint JNICALL
Java_jtux_JTuxInterop_tpgprio(JNIEnv *env, jclass cls)
{
    return tpgprio();
}

JNIEXPORT jint JNICALL
Java_jtux_JTuxInterop_tpsprio(JNIEnv *env, jclass cls, jint prio, 
    jint flags)
{
    return tpsprio(prio, flags);
}

JNIEXPORT jboolean JNICALL
Java_jtux_JTuxInterop_tpsetunsol(JNIEnv *env, jclass cls, 
    jboolean clear)
{
    return (tpsetunsol(clear ? NULL : tpunsol) != TPUNSOLERR);
}

JNIEXPORT jint JNICALL
Java_jtux_JTuxInterop_tpchkunsol(JNIEnv *env, jclass cls)
{
    return tpchkunsol();
}

JNIEXPORT jint JNICALL
Java_jtux_JTuxInterop_tpbroadcast(JNIEnv *env, jclass cls, jstring lmid, 
    jstring usrname, jstring cltname, jobject data, jint len, jint flags)
{
    jint result;

    char *c_lmid;
    char *c_usrname;
    char *c_cltname;
    char *c_data;

    GET_STRING_UTF_CHARS(lmid, done);
    GET_STRING_UTF_CHARS(usrname, done_after_lmid);
    GET_STRING_UTF_CHARS(cltname, done_after_usrname);

    GET_INPUT_BUFFER(data, done_after_cltname);

    result = tpbroadcast(c_lmid, c_usrname, c_cltname, c_data, len, flags);

done_after_cltname:
    RELEASE_STRING_UTF_CHARS(cltname);

done_after_usrname:
    RELEASE_STRING_UTF_CHARS(usrname);

done_after_lmid:
    RELEASE_STRING_UTF_CHARS(lmid);

done:
    return result;
}

JNIEXPORT jint JNICALL
Java_jtux_JTuxInterop_tpnotify(JNIEnv *env, jclass cls, jobject clientid, 
    jobject data, jint len, jint flags)
{
    jint result = 0;

    char *c_data;

    GET_INPUT_BUFFER(data, done);

    if (clientid == NULL) {
        result = tpnotify(NULL, c_data, len, flags);
    } else {
        CLIENTID c_clientid;
        read_CLIENTID(env, clientid, &c_clientid);
        result = tpnotify(&c_clientid, c_data, len, flags);
    }

done:
    return result;
}

JNIEXPORT jint JNICALL
Java_jtux_JTuxInterop_tppost(JNIEnv *env, jclass cls, jstring event, 
    jobject data, jint len, jint flags)
{
    jint result = 0;

    char *c_event;
    char *c_data;

    GET_STRING_UTF_CHARS(event, done);

    GET_INPUT_BUFFER(data, done_after_event);

    result = tppost(c_event, c_data, len, flags);

done_after_event:
    RELEASE_STRING_UTF_CHARS(event);

done:
    return result;
}

JNIEXPORT jint JNICALL
Java_jtux_JTuxInterop_tpsubscribe(JNIEnv *env, jclass cls, 
    jstring eventexpr, jstring filter, jobject ctl, jint flags)
{
    jint result = 0;

    char *c_eventexpr;
    char *c_filter;

    GET_STRING_UTF_CHARS(eventexpr, done);
    GET_STRING_UTF_CHARS(filter, done_after_eventexpr);

    if (ctl == NULL) {
        result = tpsubscribe(c_eventexpr, c_filter, NULL, flags);
    } else {
        TPEVCTL c_ctl;
        if (read_TPEVCTL(env, ctl, &c_ctl) == -1) {
            goto done_after_filter;
        }
        result = tpsubscribe(c_eventexpr, c_filter, &c_ctl, flags);
    }

done_after_filter:
    RELEASE_STRING_UTF_CHARS(filter);

done_after_eventexpr:
    RELEASE_STRING_UTF_CHARS(eventexpr);

done:
    return result;
}

JNIEXPORT jint JNICALL
Java_jtux_JTuxInterop_tpunsubscribe(JNIEnv *env, jclass cls, 
    jint subscription, jint flags)
{
    return tpunsubscribe(subscription, flags);
}

JNIEXPORT jint JNICALL
Java_jtux_JTuxInterop_tpgetmbenc(JNIEnv *env, jclass cls, jobject buffer, 
    jobject encHolder, jint flags)
{
    jint result;

    /*
    * c_enc should be at least NL_LANGMAX + 1 in size but NL_LANGMAX is
    * not defined on Windows. So we define NL_LANGMAX to be 255 if it is
    * not defined. This should be more than enough as a typical NL_LANGMAX
    * is 14 but 31 also occurs.
    */

#ifndef NL_LANGMAX
#define NL_LANGMAX 255
#endif

    char *c_buffer;
    char c_enc[NL_LANGMAX + 1];

    GET_INPUT_BUFFER(buffer, done);

    result = tpgetmbenc(c_buffer, (encHolder == NULL) ? NULL : c_enc, flags);

    if (result != -1) {
        if (encHolder != NULL) {
            c_enc[NL_LANGMAX] = 0;
            { SET_STRING_HOLDER_VALUE(enc, done); }
        }
    }

done:
    return result;
}

JNIEXPORT jint JNICALL
Java_jtux_JTuxInterop_tpsetmbenc(JNIEnv *env, jclass cls, jobject buffer, 
    jstring enc, jint flags)
{
    jint result = 0;

    char *c_buffer;
    char *c_enc;

    GET_INPUT_BUFFER(buffer, done);
    GET_STRING_UTF_CHARS(enc, done);

    result = tpsetmbenc(c_buffer, c_enc, flags);

    RELEASE_STRING_UTF_CHARS(enc);

done:
    return result;
}

#define GET_INPUT_FBFR(VAR, EXCEPTION_LABEL) \
    if (VAR == NULL) { \
        JTuxThrowIllegalArgumentException(env, "null buffer"); \
        goto EXCEPTION_LABEL; \
    } else { \
        c_##VAR = (FBFR32 *) (*env)->GetDirectBufferAddress(env, VAR); \
        if (c_##VAR == NULL) { \
            goto EXCEPTION_LABEL; \
        } \
    }

static int CFadd32_primitive(JNIEnv *env, jobject fbfr, jint fldid,
    int type, void *value)
{
    jint result = 0;

    FBFR32 *c_fbfr;

    GET_INPUT_FBFR(fbfr, done);

    result = CFadd32(c_fbfr, fldid, (char *) value, 0, type);

done:
    return result;
}

static jint CFchg32_primitive(JNIEnv *env, jobject fbfr, jint fldid,
    int occ, int type, void *value)
{
    jint result = 0;

    FBFR32 *c_fbfr;

    GET_INPUT_FBFR(fbfr, done);

    result = CFchg32(c_fbfr, fldid, occ, (char *) value, 0, type);

done:
    return result;
}

static int CFget32_primitive(JNIEnv *env, jobject fbfr, jint fldid,
    jint occ, int type, void *value)
{
    int result;

    FBFR32 *c_fbfr;

    GET_INPUT_FBFR(fbfr, done);

    result = CFget32(c_fbfr, (FLDID32) fldid, (FLDOCC32) occ,
        (char *) value, NULL, type);

done:
    return result;
}

JNIEXPORT jint JNICALL
Java_jtux_JTuxInterop_Ferror32(JNIEnv *env, jclass cls)
{
    return Ferror32;
}

JNIEXPORT jstring JNICALL
Java_jtux_JTuxInterop_Fstrerror32(JNIEnv *env, jclass cls, jint err)
{
    char *errMessage = Fstrerror32(err);
    if (errMessage == NULL) {
        return NULL;
    }
    return (*env)->NewStringUTF(env, errMessage);
}

JNIEXPORT jint JNICALL
Java_jtux_JTuxInterop_CFaddByte32(JNIEnv *env, jclass cls, jobject fbfr, 
    jint fldid, jbyte value)
{
    return CFadd32_primitive(env, fbfr, fldid, FLD_CHAR, &value);
}

JNIEXPORT jint JNICALL
Java_jtux_JTuxInterop_CFaddShort32(JNIEnv *env, jclass cls, jobject fbfr, 
    jint fldid, jshort value)
{
    return CFadd32_primitive(env, fbfr, fldid, FLD_SHORT, &value);
}

JNIEXPORT jint JNICALL
Java_jtux_JTuxInterop_CFaddInt32(JNIEnv *env, jclass cls, jobject fbfr, 
    jint fldid, jint value)
{
    return CFadd32_primitive(env, fbfr, fldid, FLD_LONG, &value);
}

JNIEXPORT jint JNICALL
Java_jtux_JTuxInterop_CFaddFloat32(JNIEnv *env, jclass cls, jobject fbfr,
    jint fldid, jfloat value)
{
    return CFadd32_primitive(env, fbfr, fldid, FLD_FLOAT, &value);
}

JNIEXPORT jint JNICALL
Java_jtux_JTuxInterop_CFaddDouble32(JNIEnv *env, jclass cls, jobject fbfr, 
    jint fldid, jdouble value)
{
    return CFadd32_primitive(env, fbfr, fldid, FLD_DOUBLE, &value);
}

JNIEXPORT jint JNICALL
Java_jtux_JTuxInterop_CFaddBytes32(JNIEnv *env, jclass cls, jobject fbfr, 
    jint fldid, jbyteArray value)
{
    jint result = 0;

    FBFR32 *c_fbfr;

    GET_INPUT_FBFR(fbfr, done);

    if (value == NULL) {
        result = CFadd32(c_fbfr, fldid, NULL, 0, FLD_CARRAY);
        /* returns FEINVAL, see CFadd32(3c) */
    } else {
        jsize len = (*env)->GetArrayLength(env, value);
        void *bytes = (*env)->GetPrimitiveArrayCritical(env, value, NULL);
        if (bytes == NULL) {
            goto done;
        }
        result = CFadd32(c_fbfr, fldid, (char *) bytes, len, FLD_CARRAY);
        (*env)->ReleasePrimitiveArrayCritical(env, value, bytes, JNI_ABORT);
    }

done:
    return result;
}

JNIEXPORT jint JNICALL
Java_jtux_JTuxInterop_CFchgByte32(JNIEnv *env, jclass cls, jobject fbfr, 
    jint fldid, jint occ, jbyte value)
{
    return CFchg32_primitive(env, fbfr, fldid, occ, FLD_CHAR, &value);
}

JNIEXPORT jint JNICALL
Java_jtux_JTuxInterop_CFchgShort32(JNIEnv *env, jclass cls, jobject fbfr,
    jint fldid, jint occ, jshort value)
{
    return CFchg32_primitive(env, fbfr, fldid, occ, FLD_SHORT, &value);
}

JNIEXPORT jint JNICALL
Java_jtux_JTuxInterop_CFchgInt32(JNIEnv *env, jclass cls, jobject fbfr, 
    jint fldid, jint occ, jint value)
{
    return CFchg32_primitive(env, fbfr, fldid, occ, FLD_LONG, &value);
}

JNIEXPORT jint JNICALL
Java_jtux_JTuxInterop_CFchgFloat32(JNIEnv *env, jclass cls, jobject fbfr, 
    jint fldid, jint occ, jfloat value)
{
    return CFchg32_primitive(env, fbfr, fldid, occ, FLD_FLOAT, &value);
}

JNIEXPORT jint JNICALL
Java_jtux_JTuxInterop_CFchgDouble32(JNIEnv *env, jclass cls, jobject fbfr, 
    jint fldid, jint occ, jdouble value)
{
    return CFchg32_primitive(env, fbfr, fldid, occ, FLD_DOUBLE, &value);
}

JNIEXPORT jint JNICALL
Java_jtux_JTuxInterop_CFchgBytes32(JNIEnv *env, jclass cls, jobject fbfr, 
    jint fldid, jint occ, jbyteArray value)
{
    jint result = 0;

    FBFR32 *c_fbfr;

    GET_INPUT_FBFR(fbfr, done);

    if (value == NULL) {
        result = CFchg32(c_fbfr, fldid, occ, NULL, 0, FLD_CARRAY);
        /* returns FEINVAL, see CFchg32(3c) */
    } else {
        jsize len = (*env)->GetArrayLength(env, value);
        void *bytes = (*env)->GetPrimitiveArrayCritical(env, value, NULL);
        if (bytes == NULL) {
            goto done;
        }
        result = CFchg32(c_fbfr, fldid, occ, (char *) bytes, len, FLD_CARRAY);
        (*env)->ReleasePrimitiveArrayCritical(env, value, bytes, JNI_ABORT);
    }

done:
    return result;
}

JNIEXPORT jbyte JNICALL
Java_jtux_JTuxInterop_CFgetByte32(JNIEnv *env, jclass cls, jobject fbfr, 
    jint fldid, jint occ)
{
    jbyte value;
    if (CFget32_primitive(env, fbfr, fldid, occ, FLD_CHAR, &value) == -1) {
        value = 0;
    } else if (value == 0) {
        Ferror32 = 0;
    }
    return value;
}

JNIEXPORT jshort JNICALL
Java_jtux_JTuxInterop_CFgetShort32(JNIEnv *env, jclass cls, jobject fbfr,
    jint fldid, jint occ)
{
    jshort value;
    if (CFget32_primitive(env, fbfr, fldid, occ, FLD_SHORT, &value) == -1) {
        value = 0;
    } else if (value == 0) {
        Ferror32 = 0;
    }
    return value;
}

JNIEXPORT jint JNICALL
Java_jtux_JTuxInterop_CFgetInt32(JNIEnv *env, jclass cls, jobject fbfr, 
    jint fldid, jint occ)
{
    jint value;
    if (CFget32_primitive(env, fbfr, fldid, occ, FLD_LONG, &value) == -1) {
        value = 0;
    } else if (value == 0) {
        Ferror32 = 0;
    }
    return value;
}

JNIEXPORT jfloat JNICALL
Java_jtux_JTuxInterop_CFgetFloat32(JNIEnv *env, jclass cls, jobject fbfr, 
    jint fldid, jint occ)
{
    jfloat value;
    if (CFget32_primitive(env, fbfr, fldid, occ, FLD_FLOAT, &value) == -1) {
        value = 0;
    } else if (value == 0) {
        Ferror32 = 0;
    }
    return value;
}

JNIEXPORT jdouble JNICALL
Java_jtux_JTuxInterop_CFgetDouble32(JNIEnv *env, jclass cls, jobject fbfr, 
    jint fldid, jint occ)
{
    jdouble value;
    if (CFget32_primitive(env, fbfr, fldid, occ, FLD_DOUBLE, &value) == -1) {
        value = 0;
    } else if (value == 0) {
        Ferror32 = 0;
    }
    return value;
}

JNIEXPORT jbyteArray JNICALL
Java_jtux_JTuxInterop_CFfindBytes32(JNIEnv *env, jclass cls, jobject fbfr, 
    jint fldid, jint occ)
{
    jbyteArray result = NULL;

    FBFR32 *c_fbfr;

    char *bytes;
    FLDLEN32 len;

    GET_INPUT_FBFR(fbfr, done);

    bytes = CFfind32(c_fbfr, fldid, occ, &len, FLD_CARRAY);
    if (bytes != NULL) {
        result = (*env)->NewByteArray(env, len);
        if (result != NULL) {
            (*env)->SetByteArrayRegion(env, result, 0, len, (jbyte *) bytes);
        }
    }

done:
    return result;
}

JNIEXPORT jint JNICALL
Java_jtux_JTuxInterop_Fdel32(JNIEnv *env, jclass cls, jobject fbfr, 
    jint fldid, jint occ)
{
    jint result = 0;

    FBFR32 *c_fbfr;

    GET_INPUT_FBFR(fbfr, done);

    result = Fdel32(c_fbfr, fldid, occ);

done:
    return result;
}

JNIEXPORT jint JNICALL
Java_jtux_JTuxInterop_Fdelall32(JNIEnv *env, jclass cls, jobject fbfr, 
    jint fldid)
{
    jint result = 0;

    FBFR32 *c_fbfr;

    GET_INPUT_FBFR(fbfr, done);

    result = Fdelall32(c_fbfr, fldid);

done:
    return result;
}

JNIEXPORT jint JNICALL
Java_jtux_JTuxInterop_Finit32(JNIEnv *env, jclass cls, jobject fbfr, 
    jint buflen)
{
    jint result = 0;

    FBFR32 *c_fbfr;

    GET_INPUT_FBFR(fbfr, done);

    result = Finit32(c_fbfr, buflen);

done:
    return result;
}

JNIEXPORT jint JNICALL
Java_jtux_JTuxInterop_Fldid32(JNIEnv *env, jclass cls, jstring name)
{
    jint result = 0;

    char *c_name;

    GET_NON_NULL_STRING_UTF_CHARS(name, done);

    result = Fldid32(c_name);

    RELEASE_NON_NULL_STRING_UTF_CHARS(name);

done:
    return result;
}

JNIEXPORT jint JNICALL
Java_jtux_JTuxInterop_Fldno32(JNIEnv *env, jclass cls, jint fldid)
{
    return Fldno32(fldid);
}

JNIEXPORT jint JNICALL
Java_jtux_JTuxInterop_Fldtype32(JNIEnv *env, jclass cls, jint fldid)
{
    return Fldtype32(fldid);
}

JNIEXPORT jint JNICALL
Java_jtux_JTuxInterop_Flen32(JNIEnv *env, jclass cls, jobject fbfr, 
    jint fldid, jint occ)
{
    jint result = 0;

    FBFR32 *c_fbfr;

    GET_INPUT_FBFR(fbfr, done);

    result = Flen32(c_fbfr, fldid, occ);

done:
    return result;
}

JNIEXPORT jint JNICALL
Java_jtux_JTuxInterop_Fmkfldid32(JNIEnv *env, jclass cls, jint type, 
    jint num)
{
    return Fmkfldid32(type, num);
}

JNIEXPORT jstring JNICALL
Java_jtux_JTuxInterop_Fname32(JNIEnv *env, jclass cls, jint fldid)
{
    char *name = Fname32(fldid);
    if (name == NULL) {
        return NULL;
    }
    return (*env)->NewStringUTF(env, name);
}

JNIEXPORT jint JNICALL
Java_jtux_JTuxInterop_Fnext32(JNIEnv *env, jclass cls, jobject fbfr, 
    jobject fldid, jobject occ)
{
    jint result = 0;

    FBFR32 *c_fbfr;
    FLDID32 c_fldid;
    FLDOCC32 c_occ;

    GET_INPUT_FBFR(fbfr, done);

    if (fldid == NULL) {
        JTuxThrowIllegalArgumentException(env, "null fldid holder");
        goto done;
    }

    if (occ == NULL) {
        JTuxThrowIllegalArgumentException(env, "null occ holder");
        goto done;
    }

    c_fldid = jtux_holders_IntHolder_get_value(env, fldid);

    c_occ = jtux_holders_IntHolder_get_value(env, occ);

    result = Fnext32(c_fbfr, &c_fldid, &c_occ, NULL, NULL);
    if (result != -1) {
        jtux_holders_IntHolder_set_value(env, fldid, c_fldid);
        jtux_holders_IntHolder_set_value(env, occ, c_occ);
    }

done:
    return result;
}

JNIEXPORT jint JNICALL
Java_jtux_JTuxInterop_Fnum32(JNIEnv *env, jclass cls, jobject fbfr)
{
    jint result = 0;

    FBFR32 *c_fbfr;

    GET_INPUT_FBFR(fbfr, done);

    result = Fnum32(c_fbfr);

done:
    return result;
}

JNIEXPORT jint JNICALL
Java_jtux_JTuxInterop_Foccur32(JNIEnv *env, jclass cls, jobject fbfr, 
    jint fldid)
{
    jint result = 0;

    FBFR32 *c_fbfr;

    GET_INPUT_FBFR(fbfr, done);

    result = Foccur32(c_fbfr, fldid);

done:
    return result;
}

JNIEXPORT jint JNICALL
Java_jtux_JTuxInterop_Fsizeof32(JNIEnv *env, jclass cls, jobject fbfr)
{
    jint result = 0;

    FBFR32 *c_fbfr;

    GET_INPUT_FBFR(fbfr, done);

    result = Fsizeof32(c_fbfr);

done:
    return result;
}

JNIEXPORT jstring JNICALL
Java_jtux_JTuxInterop_Ftype32(JNIEnv *env, jclass cls, jint fldid)
{
    char *type = Ftype32((FLDID32) fldid);
    if (type == NULL) {
        return NULL;
    }
    return (*env)->NewStringUTF(env, type);
}

JNIEXPORT jint JNICALL
Java_jtux_JTuxInterop_Funused32(JNIEnv *env, jclass cls, jobject fbfr)
{
    jint result = 0;

    FBFR32 *c_fbfr;

    GET_INPUT_FBFR(fbfr, done);

    result = Funused32(c_fbfr);

done:
    return result;
}

JNIEXPORT jint JNICALL
Java_jtux_JTuxInterop_Fused32(JNIEnv *env, jclass cls, jobject fbfr)
{
    jint result = 0;

    FBFR32 *c_fbfr;

    GET_INPUT_FBFR(fbfr, done);

    result = Fused32(c_fbfr);

done:
    return result;
}

/* 
 * Note that an underscore in a Java method name maps to _1 in the
 * C function name.
 */

JNIEXPORT void JNICALL
Java_jtux_JTuxInterop_Fidnm_1unload32(JNIEnv *env, jclass cls)
{
    Fidnm_unload32();
}

JNIEXPORT void JNICALL
Java_jtux_JTuxInterop_Fnmid_1unload32(JNIEnv *env, jclass cls)
{
    Fnmid_unload32();
}
